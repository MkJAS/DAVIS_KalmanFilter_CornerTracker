classdef Corner < handle
    %Corner Class to contain all associated data and functions for a corner feature
    %   Detailed explanation goes here

    properties (Access = private)
        
        x;                  %initial x measurment: Found by manually going through Events to find on closest to harris corner detection
        y;                  %initial y measurment
        t1;
        xd;                 %initial velocity measurment not really relevant anyways
        yd;                 %initial y velocity measurment
        acc;                %'acceleration'

        dt;                 %time step
        F;                  %process matrix
        W;                  
        Q;                  %Process covariance?
        H;                  %measurment matrix
        E;                  %covariance
        Xp;                 %x_hat/KF x   
        R;                  %measurment covariance matrix

        skip;               %skip for when no measurment is found
        num_skips;          %number of skips in a row for a corner
        size_t1;            %size of previous possible features
        iter;               %count for message number/loop number
        num_corners;        %number of corners input
        corner_relat;       %corner position relations to each other

        %plots 
        el;                 %ellipse plot
        g;                  %feature selected as measurment
        cr;                 %KF prediction position
             
    end
    properties (Access = public)
        KF_feature;             %stores points calculated by KF
        avgs;                   %average position out of those found within error ellipse
        cmd_Xp;                 %prediction matrix containing predicted positions and velocities

    end 

    methods
        %% Initialise matrices and constants
        function self = Corner(KFvariables)
            % Construct an instance of this class
            self.num_corners = size(KFvariables,2);
            self.num_skips = zeros(self.num_corners,1);
            self.avgs = cell(self.num_corners,1);
            self.corner_relat = zeros(self.num_corners-1,2,self.num_corners);
            %Loop here for each corner being 'tracked'
            for C_idx = 1:size(KFvariables,2)
                xd_ = KFvariables{C_idx}{1};                %velocity
                yd_ = KFvariables{C_idx}{2};                %velocity
                x_ = KFvariables{C_idx}{3};                 %initial x state. Taken from harris corner detection on octogon shape 
                y_ = KFvariables{C_idx}{4};                 %initial y state 
    
    
                self.x(C_idx) = KFvariables{C_idx}{5};            %initial x measurment: Found by manually going through Events to find on closest to harris corner detection
                self.y(C_idx) = KFvariables{C_idx}{6};            %initial y measurment
                self.t1(C_idx) = KFvariables{C_idx}{7};
                self.xd(C_idx) = KFvariables{C_idx}{8};           %initial velocity measurment not really relevant anyways
                self.yd(C_idx) = KFvariables{C_idx}{9};           %initial y velocity measurment
                self.acc(C_idx) = KFvariables{C_idx}{10};         %'acceleration'
                        
                w = KFvariables{C_idx}{11};                       %process noise 
                vx = KFvariables{C_idx}{12};                      %x measurment noise:  stddv of the events were 4-5 pixels
                vy = KFvariables{C_idx}{13};                      %y measurment noise 
    
                num_messages = KFvariables{C_idx}{14};
                
                %Initialise storing matrices
                self.KF_feature(:,:,C_idx) = zeros(num_messages,2);
                self.cmd_Xp = cell(1,6);
                self.dt = KFvariables{C_idx}{15};           %time steps   
                
                X_ = [x_;                                   %initial state matrix
                       y_;
                       xd_;
                       yd_];
                self.Xp{C_idx} = X_;                        %Initialise first KF reading         
                                   
                self.R{C_idx} = [vx^2 0;                    %measurment covariance matrix
                                 0 vy^2];
            end                                         %End loop here, the following variables are same for each corner since they belong to the same system/object
            num_messages = KFvariables{1}{14};
            self.F = cell(num_messages,1);              %Initialise F,W,Q matrices
            self.W = cell(num_messages,1);
            self.Q = cell(num_messages,1);
            %Loop to populate F,W,Q matrices since dt changes slighty between
            %each message
            for j=1:num_messages
                 self.F{j} = [1 0 self.dt(j) 0;      %state update matrice
                            0 1 0 self.dt(j);
                            0 0 1 0;
                            0 0 0 1];
                         
                self.W{j} = [1/2*self.dt(j)^2;    %
                            1/2*self.dt(j)^2;
                            self.dt(j);
                            self.dt(j)];
    
                 self.Q{j} = [self.dt(j)^4 0 self.dt(j)^3 0;        %covariance
                            0 self.dt(j)^4 0 self.dt(j)^3;
                            self.dt(j)^3 0 self.dt(j)^2 0;
                            0 self.dt(j)^3 0 self.dt(j)^2].*w^2;
            end  
            self.H = [1 0 0 0;                                      %measurment matrix 
                      0 1 0 0];
    
            for l = 1:self.num_corners
                self.E{l} = self.Q{1};                         %set initial variance
            end
            self.size_t1(C_idx) = 100000;       
            self.iter = 1;  
            for i=1:self.num_corners                           %Obtain positional relations between each corner from each other corner
                count = 1;
                for j=1:self.num_corners
                    if i ~= j                               %check to exclude a corner checking relation to itself
                        self.corner_relat(count,1,i) = self.x(i) - self.x(j);
                        self.corner_relat(count,2,i) = self.y(i) - self.y(j);
                        count = count + 1;
                    end 
                end
            end
        end

%% KF Loop
        function KF_loop(self,xyt)
           for C_idx = 1:self.num_corners
                %initial measurment
                Xm = [self.x(C_idx);
                    self.y(C_idx);
                    self.xd(C_idx);
                    self.yd(C_idx);];                  
                self.skip = false;
                try delete(self.g); end;
                if self.iter > 1
                    %Get ellipse bounds
                    [a,b,h,k,ell] = error_ellipse([self.KF_feature(self.iter-1,1,C_idx) self.KF_feature(self.iter-1,2,C_idx)],self.E{C_idx}(1:2,1:2));     %get ellipse bounds
                    try delete(self.el); end;
                    self.el = plot(ell(:,1) + h,ell(:,2) + k,'-');         %Plot ellipse around KF point
                    %Get features that are inside the ellipse, with the
                    %most likely one placed at the top of the list
                    t2 = self.getPointsInEllisp(xyt(1,:),[self.KF_feature(self.iter-1,1,C_idx) self.KF_feature(self.iter-1,2,C_idx)],a,b,self.t1(C_idx),C_idx);    
                    size_t2 = size(t2,1);
                    %If t2 returns and is NOT empty
                    if size_t2 ~= 0         
                        Xm(1) = t2(1,1);                                   %Extract value from t2 and set as measurment                 
                        Xm(2) = t2(1,2);
                        self.t1(C_idx) = xyt{1,3}{t2(1,5)}.Ns*10^-9 + xyt{1,3}{t2(1,5)}.s; %Update last event time
                        self.g = plot(Xm(1),Xm(2),'*','color','g');                    %Plot the t2 point as green *
                    %If t2 returns and IS empty, make ellipse a little
                    %bigger to see if there are any features just out of
                    %reach and check again
                    else
                        [a,b,h,k,ell] = error_ellipse([self.KF_feature(self.iter-1,1,C_idx) self.KF_feature(self.iter-1,2,C_idx)],1.5*self.E{C_idx}(1:2,1:2));     %get ellipse bounds
                        try delete(self.el); end;
                        self.el = plot(ell(:,1) + h,ell(:,2) + k,'-');
                        [t2,p2] = self.getPointsInEllisp(xyt(1,:),[self.KF_feature(self.iter-1,1,C_idx) self.KF_feature(self.iter-1,2,C_idx)],a,b,self.t1(C_idx),C_idx);    
                        size_t2 = size(t2,1);
                        %If t2 is no longer 0
                        if size_t2 ~= 0
                            Xm(1) = t2(1,1);                 
                            Xm(2) = t2(1,2);
                            self.t1(C_idx) = xyt{1,3}{t2(1,5)}.Ns*10^-9 + xyt{1,3}{t2(1,5)}.s;
                            self.g = plot(Xm(1),Xm(2),'*','color','g');
                            self.num_skips(C_idx) = 0;
                        %If t2 is STILL empty, take the closest feature event to
                        %the predicted point as the measurment and set skip
                        %to true 
                        else 
                            [idx,D] = knnsearch([xyt{1,1} xyt{1,2}],[p2(1) p2(2)]);
                            Xm(1) = p2(1);    
                            Xm(2) = p2(2);    
                            self.skip = true;
                            self.num_skips(C_idx) = self.num_skips(C_idx) + 1;
                            self.g = plot(Xm(1),Xm(2),'*','color','g');
                            self.t1(C_idx) = xyt{1,3}{idx}.Ns*10^-9 + xyt{1,3}{idx}.s;       
                        end   
                    end 
                    self.size_t1(C_idx) = size_t2;                         %update size of points in ellipse
                end 
                self.KFupdate(Xm,C_idx);                                   %update step
           end 
            self.iter = self.iter + 1;
        end 
 %%
        function KFupdate(self,Xm,C_idx)
            avg_acc = self.acc(1);
            %This block of code is designed to create a dynamic update step
            %wherein the acceleration applied to the process is not a
            %static variable but based off of previous data points and
            %their apparant trajectories
            if self.iter > 2
                %If it is less than 2 the math below wont work
                    %Calculate velocity from last step to current step and
                    %then the velocity from 2 steps ago and last step so
                    %that acceleration between those two points can be
                    %calculated
                    vel2 =  self.cmd_Xp{C_idx}(3:4,:,self.iter-1);
                    vel1 = self.cmd_Xp{C_idx}(3:4,:,self.iter-2);
                    avg_acc = (vel2-vel1)/self.dt(self.iter);
                    %Calculate total acceleration as a vector of x and y
                    %checking the direction of travel to determine whether
                    %acceleration is actually a decceleration or simply
                    %accelerating in the other direction
                    
                    %If velocity decreased and both were negative = decceleration
                    if vel2(1)-vel1(1)>0 && vel2(1)<0 && vel1(1)<0
                        avg_acc(1) = -avg_acc(1);
                    end
                    if vel2(2)-vel1(2)>0 && vel2(2)<0 && vel1(2)<0
                        avg_acc(2) = -avg_acc(2);
                    end
                    %If velocity increased and both were negative = acceleration  
                    if vel2(1)-vel1(1)<0 && vel2(1)<0 && vel1(1)<0
                        avg_acc(1) = avg_acc(1);
                    end
                    if vel2(2)-vel1(2)<0 && vel2(2)<0 && vel1(2)<0
                        avg_acc(2) = avg_acc(2);
                    end
                    %if velocity decreased and both positive = decceleration
                    if vel2(1)-vel1(1)<0 && vel2(1)>0 && vel1(1)>0
                        avg_acc(1) = -avg_acc(1);
                    end
                    if vel2(2)-vel1(2)<0 && vel2(2)>0 && vel1(2)>0
                        avg_acc(2) = -avg_acc(2);
                    end
                    avg_acc = [avg_acc;avg_acc];

            end

            %Update Xp
            self.Xp{C_idx} = self.F{self.iter} * self.Xp{C_idx} + self.W{self.iter} .* avg_acc;
            %Update E
            self.E{C_idx} = self.F{self.iter} * self.E{C_idx} * self.F{self.iter}' + self.Q{self.iter};                 %Predict next covariance
            %Calculate K
            K = self.E{C_idx}*self.H'*inv(self.H*self.E{C_idx}*self.H'+[100 0;0 100]);          %If it is determined that there were no events, i.e. no measurments set noise really high so it the Kalman gain ignores it
            %If no measurments were taken earlier, leave K as above, in
            %order to ignore the measurment component, otherwise override
            %the above line with the line below
            if self.skip == false  
                K = self.E{C_idx}*self.H'*inv(self.H*self.E{C_idx}*self.H'+self.R{C_idx});           %Kalman Gain     K = E*H'*inv(H*E*H'+R);
            end 
            %Predict next Xp
            self.Xp{C_idx} = self.Xp{C_idx} + K*(Xm(1:2,:) - self.H*self.Xp{C_idx});                     %update state estimate
            
            self.cmd_Xp{C_idx}(:,:,self.iter) = self.Xp{C_idx};
            cdmXp = self.Xp{C_idx}                                                              %print to console                         
            self.KF_feature(self.iter,:,C_idx) = [self.Xp{C_idx}(1) self.Xp{C_idx}(2)];         %extract x,y pos
            %Predict next E
            self.E{C_idx} = (eye(4) - K*self.H)*self.E{C_idx};                                    %update covariance estimate
%             try delete(self.cr); end;
            self.cr = scatter(self.KF_feature(self.iter,1,C_idx),self.KF_feature(self.iter,2,C_idx),'+','k');
        end
    end 

    methods (Access = private)
%% Look for features within the elipse bounds & determine which to choose if any
    function [features,P] = getPointsInEllisp(self,curr_features,KF_feature,a,b,t1,C_idx)
        % Gets the events from the next message which fall within the
        % bounds of the ellipse
        features = zeros(10,5);
        counter = 1;
        %Search through all events and select those that fall within
        %the bounds of the ellipse and within 0.05 seconds of the last one
        for j=1:size(curr_features{1},1)
            if (curr_features{1,1}(j)-KF_feature(1))^2/b^2 + (curr_features{1,2}(j)-KF_feature(2))^2/a^2 < 1 %&&  0.055>((next_features{1,3}{j}.Ns*10^-9 + next_features{1,3}{j}.s) - t1)  %(x-x0)^2 + (y-y0)^2 < r^2, the point (x,y) is inside the circle,
                if (curr_features{1,3}{j}.Ns*10^-9 + curr_features{1,3}{j}.s) - t1 < 0.05
                    features(counter,1) = curr_features{1,1}(j);    %x coordinate
                    features(counter,2) = curr_features{1,2}(j);    %y coordinate
                    features(counter,3) = pdist([KF_feature(1,1),KF_feature(1,2);curr_features{1,1}(j),curr_features{1,2}(j)]); %distance of the feature to the KF point
                    features(counter,4) = (curr_features{1,3}{j}.Ns*10^-9 + curr_features{1,3}{j}.s) - t1;  %the time between this feature and the last
                    features(counter,5) = j;                                                                %the features index in the ROS message
                    counter = counter + 1;
                end
            end 
        end
        features = features(any(features,2),:);                            %remove any zeros
        features = sortrows(features,[4 3]);                               %sort by time
        [~,uidx] = unique(features(:,[1 2]),'rows','stable');              %remove any double events at same pixel, keep smallest t diff as sorted above
        features = features(uidx,:);
        switch C_idx                                                        
            case 1   %for corner 1
                avgV = zeros(1,2);
                prev_set = zeros(self.num_corners-1,2);
                count = 1;
                %collect the velocities of corners2-6 from previous step
                for i=1:self.num_corners
                    if i ~= 1   %excluding the current corner in question
                        prev_set(count,:) = self.KF_feature(self.iter-1,:,i);
                        avgV(count,:) = self.Xp{count}(3:4,1)';
                        count = count + 1;
                    end 
                end
                avgV = rmoutliers(avgV);    %remove possible outliers
                avgV = mean(avgV);          %average
                p = zeros(size(prev_set,1),2);
                %using corners 2-6, obtain where each corner believed
                %corner 1 should have been 
                for i=1:size(prev_set,1)
                        p(i,:) = self.corner_relat(i,:,1) + prev_set(i,:);
                end
                p = mean(p);    %get the average 
                p2 = (self.dt(self.iter)*avgV) + p; %extropolate from that point using the average velocity calculated above and the supposed position
                P = p2;
                if (p2(1)-KF_feature(1))^2/b^2 + (p2(2)-KF_feature(2))^2/a^2 < 1    %check if p2 is within ellipse
                   [idx,D] = knnsearch(features(:,1:2),[p2(1) p2(2)]);              %find closest feature to p2,from those features that fit the criteria
                   D = pdist([features(idx,1:2);KF_feature]);              %distance from that feature and the ellipse centre
                   r = min([a b]);                                         %get the smallest ellipse radius
                    if D > r*0.8                                           %if D is larger than a 0.8times the minor radius
                        features = [];                                     %empty the matrix and set skip to true
                        self.skip = true;
                    else
                        features = features(idx,:);                        %if D is smaller, select it as the measrument
                    end 
                else    %if p2 is outside of the ellipse find the closest point outside the el
                    [idx,D] = knnsearch([curr_features{:,1} curr_features{:,2}],[p2(1) p2(2)]);
                    features(1,1) = curr_features{1,1}(idx);    
                    features(1,2) = curr_features{1,2}(idx);    
                    features(1,3) = pdist([KF_feature(1,1),KF_feature(1,2);curr_features{1,1}(idx),curr_features{1,2}(idx)]);
                    features(1,4) = (curr_features{1,3}{idx}.Ns*10^-9 + curr_features{1,3}{idx}.s) - t1;
                    features(1,5) = idx;
                    self.skip = true;
                end
            otherwise   %for all other corners
                curr_point = self.KF_feature(self.iter,:,1);
                p = self.corner_relat(1,:,C_idx) + curr_point;
                P = p;
                if (p(1)-KF_feature(1))^2/b^2 + (p(2)-KF_feature(2))^2/a^2 < 1
                   [idx,D] = knnsearch(features(:,1:2),[p(1) p(2)]);
                    r = min([a b]);
                    if D > r
                        features = features(idx,:);
                        self.skip = true;
                    else
                        features = features(idx,:);
                    end 
                else
                    [idx,D] = knnsearch([curr_features{:,1} curr_features{:,2}],[p(1) p(2)]);
                    features(1,1) = p(1);    
                    features(1,2) = p(2);    
                    features(1,3) = pdist([KF_feature(1,1),KF_feature(1,2);curr_features{1,1}(idx),curr_features{1,2}(idx)]);
                    features(1,4) = (curr_features{1,3}{idx}.Ns*10^-9 + curr_features{1,3}{idx}.s) - t1;
                    features(1,5) = idx;
                    self.skip = true;
                end
        end  

                       
%                         distance = abs([Xm(1)-p(1) Xm(2)-p(2)]);
%                     %     [~,D] = knnsearch(prev_set(:,1:2),[Xm(1) Xm(2)]);
%                         if distance(1) > 5
%                             newXm(1) = p(1);
%                             self.skip = true;
%                         end
%                         if distance(2) > 5
%                             newXm(2) = p(2);
%                             self.skip = true;
%                         end
%                         try delete (self.g); end;
%                         self.g = plot(newXm(1),newXm(2),'*','color','g');




%                 if self.num_corners > 1 && self.iter >= 3 
%                     for i = 1:self.num_corners
%                         x2 = self.KF_feature(self.iter-1,1,i);
%                         y2 = self.KF_feature(self.iter-1,2,i);
%                         x1 = self.KF_feature(self.iter-2,1,i);
%                         y1 = self.KF_feature(self.iter-2,2,i);
%                         xd(i,:) = [x2-x1,y2-y1];
%                     end
%                     m = mean(xd);    
%                     T = m*5 + KF_feature;
%                     angle = atan2(m(2),m(1));
%                     if self.iter >= 5 && ~isempty(features)
%                         for i = 1:size(features,1)
%                             p = [features(i,1)-KF_feature(1) features(i,2)-KF_feature(2)];
%                             theta = atan2(p(2),p(1));
%                             if theta > angle + 135*pi/180 || theta < angle - 135*pi/180
%                                 features(i,:) = zeros(1,5);
%                             end
%                         end
%                         features = features(any(features,2),:);
%                         if ~isempty(features)
%                                 idx = knnsearch(features(:,1:2),[T(1) T(2)]);
%                                 features = circshift(features,[(-idx+1) 0]);
%                         end
%                     end 
%                 end               
                %
    %             if ~isempty(features)
    %                 %take the avg of all feature coordinate
    %                 temp_avg = [mean(features(:,1)) mean(features(:,2))];
    %                 %add it to a storage matrix
    %                 self.avgs{C_idx} = [self.avgs{C_idx};temp_avg];
    %                 self.avg = plot(temp_avg(1),temp_avg(2),'x','color','k','LineWidth',3);
    %                 %find the feature closest to this average
    %                 idx = knnsearch(features(:,1:2),[temp_avg(1) temp_avg(2)]); 
    %                 %rearrange array such that the above point is at the top
    %                 features = circshift(features,[(-idx+1) 0]);                
    %                 num = size(self.avgs{C_idx},1);
    %                 %The below IF statement is only actioned if there are two
    %                 %recorded averages in a row, in the case that there are no
    %                 %measurments obtained, there will also NOT be an average
    %                 %thus the below section does not run.
    %                 %This is done to ensure the most recent data is being used
    %                 if num>=2
    %                     diff = self.avgs{C_idx}(num,:) - self.avgs{C_idx}(num-1,:);
    %                     %Calculate the apparent velocity of the averages
    %                     %between this loop and the previous loop so that we can
    %                     %interpolate a time step ahead and get the approximate
    %                     %location
    %                     %Since we assume that the the feature is following
    %                     %along on a similar trajectory from its previous
    %                     %location
    %                     vel_avgs = diff/self.dt(self.iter-1);   %The velocity between the last 2 averages
    %                     look_ahead_avg = vel_avgs*self.dt(self.iter) + self.avgs{C_idx}(num,:); %Where the next average would be using the above data
    %                     self.laa = scatter(look_ahead_avg(1),look_ahead_avg(2),'+','b');
    %                     try delete(self.laa); end;
    %                     %Get the feature within the ellipse that is closest to
    %                     %the proposed next average and then put it on top of t2
    %                     idx = knnsearch(features(:,1:2),[look_ahead_avg(1) look_ahead_avg(2)]);
    %                     features = circshift(features,[(-idx+1) 0]);  
    %                 end
    %             end
    
    end 



    function [newXm] = sanityCheck(self,C_idx,Xm)
        
        newXm = Xm;
        switch C_idx
            case 1
                prev_set = zeros(self.num_corners-1,2);
                count = 1;
                for i=1:self.num_corners
                    if i ~= 1   %excluding the current corner in question
                        prev_set(count,:) = self.KF_feature(self.iter-1,:,i);
                        count = count + 1;
                    end
                end
                p = zeros(size(prev_set,1),2);
                %get where it is expected the current corner would be based off of the
                %relationship established at the beginning of the run
                for i=1:size(prev_set,1)
                        p(i,:) = self.corner_relat(i,:,C_idx) + prev_set(i,:);
                end
                p = mean(p);
            otherwise
                curr_point = self.KF_feature(self.iter,:,1);
                p = self.corner_relat(1,:,C_idx) + curr_point;
        end 
        distance = abs([Xm(1)-p(1) Xm(2)-p(2)]);
    %     [~,D] = knnsearch(prev_set(:,1:2),[Xm(1) Xm(2)]);
        if distance(1) > 5
            newXm(1) = p(1);
            self.skip = true;
        end
        if distance(2) > 5
            newXm(2) = p(2);
            self.skip = true;
        end
        try delete (self.g); end;
        self.g = plot(newXm(1),newXm(2),'*','color','g');
    end 
    
    function checkBounds(self,Xm)
        if Xm(1) > 240 || Xm(1) < 0 || Xm(2) > 180 || Xm(2) < 0
               self.OoB = self.OoB + 1;
        end
    end
    
    end
end




